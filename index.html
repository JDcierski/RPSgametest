<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rock Paper Scissors Swarm</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #ui {
      padding: 8px 12px;
      background: #222;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      border-bottom: 1px solid #333;
    }
    #ui span.label {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    button {
      border: 1px solid #444;
      background: #333;
      color: #eee;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.15s, transform 0.08s, border-color 0.15s;
    }
    button:hover {
      background: #3d3d3d;
    }
    button:active {
      transform: scale(0.97);
    }
    button.tool.selected,
    #attractBtn.selected,
    #repelBtn.selected,
    #noneBtn.selected,
    #visionBtn.selected,
    #convertBtn.selected,
    #destroyBtn.selected {
      border-color: #0af;
      background: #1e3950;
    }
    #runBtn.running {
      border-color: #3fa34d;
      background: #214426;
    }
    #status {
      margin-left: auto;
      font-size: 0.9rem;
      opacity: 0.9;
      white-space: nowrap;
    }
    #gameCanvas {
      flex: 1;
      display: block;
      background: radial-gradient(circle at center, #202020, #050505 60%);
      cursor: crosshair;
    }
    details#settingsDetails {
      margin-left: 8px;
      font-size: 0.85rem;
      color: #ddd;
    }
    #settingsDetails summary {
      list-style: none;
      cursor: pointer;
      padding: 4px 10px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #333;
      user-select: none;
    }
    #settingsDetails[open] summary {
      border-color: #0af;
      background: #1e3950;
    }
    #settingsPanel {
      margin-top: 6px;
      padding: 8px;
      background: #181818;
      border-radius: 8px;
      border: 1px solid #333;
      max-width: 460px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
    }
    .setting-row {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .setting-row label {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      opacity: 0.9;
    }
    .setting-row input[type="range"] {
      width: 100%;
    }
    @media (max-width: 600px) {
      #status {
        flex-basis: 100%;
        margin-left: 0;
        margin-top: 4px;
      }
      #settingsPanel {
        max-width: 100%;
      }
    }
  </style>
</head>
<body>
  <div id="ui">
    <span class="label">Add:</span>
    <button class="tool selected" data-type="rock">Rock</button>
    <button class="tool" data-type="paper">Paper</button>
    <button class="tool" data-type="scissors">Scissors</button>
    <button class="tool" data-type="random">Random</button>

    <button id="runBtn">Run</button>
    <button id="stopBtn">Stop</button>
    <button id="clearBtn">Clear</button>

    <span class="label">Mouse:</span>
    <button id="attractBtn">Attract</button>
    <button id="repelBtn">Repel</button>
    <button id="noneBtn" class="selected">None</button>

    <span class="label">Vision:</span>
    <button id="visionBtn">Show Range</button>

    <span class="label">Mode:</span>
    <button id="convertBtn" class="selected">Convert</button>
    <button id="destroyBtn">Destroy</button>

    <details id="settingsDetails">
      <summary>Settings</summary>
      <div id="settingsPanel">
        <div class="setting-row">
          <label>
            <span>Chase speed</span>
            <span id="chaseSpeedVal">0.40</span>
          </label>
          <input type="range" id="chaseSpeed" min="0" max="1.5" step="0.01" value="0.4">
        </div>

        <div class="setting-row">
          <label>
            <span>Wander speed</span>
            <span id="wanderSpeedVal">0.06</span>
          </label>
          <input type="range" id="wanderSpeed" min="0" max="0.4" step="0.01" value="0.06">
        </div>

        <div class="setting-row">
          <label>
            <span>Sight radius</span>
            <span id="sightRadiusVal">220</span>
          </label>
          <input type="range" id="sightRadius" min="50" max="400" step="5" value="220">
        </div>

        <div class="setting-row">
          <label>
            <span>Threat radius</span>
            <span id="threatRadiusVal">220</span>
          </label>
          <input type="range" id="threatRadius" min="50" max="400" step="5" value="220">
        </div>

        <div class="setting-row">
          <label>
            <span>Flee speed</span>
            <span id="fleeSpeedVal">0.25</span>
          </label>
          <input type="range" id="fleeSpeed" min="0" max="1" step="0.01" value="0.25">
        </div>

        <div class="setting-row">
          <label>
            <span>Anti clump radius</span>
            <span id="clumpRadiusVal">70</span>
          </label>
          <input type="range" id="clumpRadius" min="20" max="200" step="5" value="70">
        </div>

        <div class="setting-row">
          <label>
            <span>Anti clump strength</span>
            <span id="clumpForceVal">0.25</span>
          </label>
          <input type="range" id="clumpForce" min="0" max="1" step="0.01" value="0.25">
        </div>

        <div class="setting-row">
          <label>
            <span>Alignment radius</span>
            <span id="alignRadiusVal">150</span>
          </label>
          <input type="range" id="alignRadius" min="20" max="300" step="5" value="150">
        </div>

        <div class="setting-row">
          <label>
            <span>Alignment force</span>
            <span id="alignForceVal">0.08</span>
          </label>
          <input type="range" id="alignForce" min="0" max="0.5" step="0.01" value="0.08">
        </div>
      </div>
    </details>

    <span id="status">No pieces. Click to add, then press Run.</span>
  </div>

  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const uiBar = document.getElementById("ui");
    const statusEl = document.getElementById("status");
    const runBtn = document.getElementById("runBtn");
    const stopBtn = document.getElementById("stopBtn");
    const clearBtn = document.getElementById("clearBtn");
    const toolButtons = document.querySelectorAll("button.tool");
    const attractBtn = document.getElementById("attractBtn");
    const repelBtn = document.getElementById("repelBtn");
    const noneBtn = document.getElementById("noneBtn");
    const visionBtn = document.getElementById("visionBtn");
    const convertBtn = document.getElementById("convertBtn");
    const destroyBtn = document.getElementById("destroyBtn");

    // Settings inputs
    const chaseSpeedInput = document.getElementById("chaseSpeed");
    const chaseSpeedVal = document.getElementById("chaseSpeedVal");
    const wanderSpeedInput = document.getElementById("wanderSpeed");
    const wanderSpeedVal = document.getElementById("wanderSpeedVal");
    const sightRadiusInput = document.getElementById("sightRadius");
    const sightRadiusVal = document.getElementById("sightRadiusVal");
    const threatRadiusInput = document.getElementById("threatRadius");
    const threatRadiusVal = document.getElementById("threatRadiusVal");
    const fleeSpeedInput = document.getElementById("fleeSpeed");
    const fleeSpeedVal = document.getElementById("fleeSpeedVal");
    const clumpRadiusInput = document.getElementById("clumpRadius");
    const clumpRadiusVal = document.getElementById("clumpRadiusVal");
    const clumpForceInput = document.getElementById("clumpForce");
    const clumpForceVal = document.getElementById("clumpForceVal");
    const alignRadiusInput = document.getElementById("alignRadius");
    const alignRadiusVal = document.getElementById("alignRadiusVal");
    const alignForceInput = document.getElementById("alignForce");
    const alignForceVal = document.getElementById("alignForceVal");

    let currentType = "rock";
    let running = false;

    const RADIUS = 12;          // physics radius
    const SPRITE_SIZE = 32;     // drawn image size

    // Tunable parameters (start at your previous values)
    let SPEED = 0.4;
    let WANDER_SPEED = 0.06;

    let DETECTION_RADIUS = 220;
    let DETECTION_RADIUS_SQ = DETECTION_RADIUS * DETECTION_RADIUS;

    let THREAT_RADIUS = 220;
    let THREAT_RADIUS_SQ = THREAT_RADIUS * THREAT_RADIUS;
    let THREAT_FORCE = 0.25;

    let SAME_TYPE_RADIUS = 70;
    let SAME_TYPE_REPEL = 0.25;

    let ALIGN_RADIUS = 150;
    let ALIGN_RADIUS_SQ = ALIGN_RADIUS * ALIGN_RADIUS;
    let ALIGN_FORCE = 0.08;

    const FRICTION = 0.98;

    const MOUSE_FORCE = 1.2;
    const MOUSE_RADIUS = 160;

    // Explosion knockback
    const EXPLOSION_RADIUS = 90;
    const KNOCKBACK_FORCE = 1.4;

    const pieces = [];
    const explosions = [];

    // Confetti
    const confetti = [];
    const CONFETTI_COUNT = 200;
    const CONFETTI_GRAVITY = 0.08;
    let celebrating = false;
    let winnerType = null;

    const mouse = {
      x: 0,
      y: 0,
      inside: false
    };
    let mouseMode = "none";
    let showVision = false;

    // Mode for combat
    let combatMode = "convert"; // or "destroy"

    // Load images
    const sprites = {
      rock: new Image(),
      paper: new Image(),
      scissors: new Image()
    };
    sprites.rock.src = "images/rock.png";
    sprites.paper.src = "images/paper.png";
    sprites.scissors.src = "images/scissor.png";

    const boomSprite = new Image();
    boomSprite.src = "images/boom.png";

    function resizeCanvas() {
      if (!canvas || !uiBar) return;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - uiBar.offsetHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function typeColor(type) {
      if (type === "rock") return "#bbbbbb";
      if (type === "paper") return "#ffeaa7";
      if (type === "scissors") return "#ff7675";
      return "#ffffff";
    }

    function beats(a, b) {
      return (
        (a === "rock" && b === "scissors") ||
        (a === "paper" && b === "rock") ||
        (a === "scissors" && b === "paper")
      );
    }

    // Tool selection
    toolButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        toolButtons.forEach(b => b.classList.remove("selected"));
        btn.classList.add("selected");
        currentType = btn.getAttribute("data-type");
      });
    });

    function updateMouseModeButtons() {
      if (!attractBtn || !repelBtn || !noneBtn) return;
      attractBtn.classList.toggle("selected", mouseMode === "attract");
      repelBtn.classList.toggle("selected", mouseMode === "repel");
      noneBtn.classList.toggle("selected", mouseMode === "none");
    }

    if (attractBtn) {
      attractBtn.addEventListener("click", () => {
        mouseMode = "attract";
        updateMouseModeButtons();
      });
    }

    if (repelBtn) {
      repelBtn.addEventListener("click", () => {
        mouseMode = "repel";
        updateMouseModeButtons();
      });
    }

    if (noneBtn) {
      noneBtn.addEventListener("click", () => {
        mouseMode = "none";
        updateMouseModeButtons();
      });
    }

    if (visionBtn) {
      visionBtn.addEventListener("click", () => {
        showVision = !showVision;
        visionBtn.classList.toggle("selected", showVision);
      });
    }

    function updateCombatModeButtons() {
      convertBtn.classList.toggle("selected", combatMode === "convert");
      destroyBtn.classList.toggle("selected", combatMode === "destroy");
    }

    convertBtn.addEventListener("click", () => {
      combatMode = "convert";
      updateCombatModeButtons();
    });

    destroyBtn.addEventListener("click", () => {
      combatMode = "destroy";
      updateCombatModeButtons();
    });

    // Settings wiring
    function hookSlider(input, label, onChange, formatter = v => v) {
      if (!input || !label) return;
      const apply = () => {
        const value = parseFloat(input.value);
        label.textContent = formatter(value);
        onChange(value);
      };
      input.addEventListener("input", apply);
      apply();
    }

    hookSlider(chaseSpeedInput, chaseSpeedVal, v => { SPEED = v; }, v => v.toFixed(2));
    hookSlider(wanderSpeedInput, wanderSpeedVal, v => { WANDER_SPEED = v; }, v => v.toFixed(2));
    hookSlider(sightRadiusInput, sightRadiusVal, v => {
      DETECTION_RADIUS = v;
      DETECTION_RADIUS_SQ = v * v;
    }, v => v.toFixed(0));
    hookSlider(threatRadiusInput, threatRadiusVal, v => {
      THREAT_RADIUS = v;
      THREAT_RADIUS_SQ = v * v;
    }, v => v.toFixed(0));
    hookSlider(fleeSpeedInput, fleeSpeedVal, v => { THREAT_FORCE = v; }, v => v.toFixed(2));
    hookSlider(clumpRadiusInput, clumpRadiusVal, v => { SAME_TYPE_RADIUS = v; }, v => v.toFixed(0));
    hookSlider(clumpForceInput, clumpForceVal, v => { SAME_TYPE_REPEL = v; }, v => v.toFixed(2));
    hookSlider(alignRadiusInput, alignRadiusVal, v => {
      ALIGN_RADIUS = v;
      ALIGN_RADIUS_SQ = v * v;
    }, v => v.toFixed(0));
    hookSlider(alignForceInput, alignForceVal, v => { ALIGN_FORCE = v; }, v => v.toFixed(2));

    // Mouse tracking
    canvas.addEventListener("mousemove", event => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = event.clientX - rect.left;
      mouse.y = event.clientY - rect.top;
      mouse.inside = true;
    });

    canvas.addEventListener("mouseleave", () => {
      mouse.inside = false;
    });

    // Spawn pieces
    canvas.addEventListener("click", event => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      let type = currentType;
      if (type === "random") {
        const options = ["rock", "paper", "scissors"];
        type = options[Math.floor(Math.random() * options.length)];
      }

      pieces.push({
        x,
        y,
        vx: 0,
        vy: 0,
        type,
        wanderAngle: Math.random() * Math.PI * 2,
        dead: false
      });
    });

    function resetCelebration() {
      celebrating = false;
      winnerType = null;
      confetti.length = 0;
    }

    function startSimulation() {
      if (pieces.length < 2) {
        statusEl.textContent = "Add at least two pieces, then press Run.";
      }
      running = true;
      runBtn.classList.add("running");
      resetCelebration();
    }

    function stopSimulation() {
      running = false;
      runBtn.classList.remove("running");
    }

    runBtn.addEventListener("click", startSimulation);
    stopBtn.addEventListener("click", stopSimulation);

    clearBtn.addEventListener("click", () => {
      pieces.length = 0;
      explosions.length = 0;
      resetCelebration();
      running = false;
      runBtn.classList.remove("running");
      statusEl.textContent = "Cleared. Click to add pieces, then press Run.";
    });

    function computeSpeedScales() {
      let rockCount = 0;
      let paperCount = 0;
      let scissorsCount = 0;

      for (const p of pieces) {
        if (p.type === "rock") rockCount++;
        else if (p.type === "paper") paperCount++;
        else if (p.type === "scissors") scissorsCount++;
      }

      const arr = [
        { type: "rock", count: rockCount },
        { type: "paper", count: paperCount },
        { type: "scissors", count: scissorsCount }
      ];

      arr.sort((a, b) => b.count - a.count);

      const speedScale = { rock: 1, paper: 1, scissors: 1 };

      speedScale[arr[0].type] = 0.6; // leader slowest
      speedScale[arr[1].type] = 0.9; // second medium
      speedScale[arr[2].type] = 1.3; // last fastest

      return speedScale;
    }

    function applyExplosionKnockback(x, y) {
      for (const p of pieces) {
        if (p.dead) continue;
        const dx = p.x - x;
        const dy = p.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        if (dist <= EXPLOSION_RADIUS) {
          const ux = dx / dist;
          const uy = dy / dist;
          const strength = (EXPLOSION_RADIUS - dist) / EXPLOSION_RADIUS * KNOCKBACK_FORCE;
          p.vx += ux * strength;
          p.vy += uy * strength;
        }
      }
    }

    function spawnConfetti() {
      confetti.length = 0;
      const w = canvas.width;
      const h = canvas.height;
      const colors = ["#ff7675", "#ffeaa7", "#74b9ff", "#55efc4", "#fd79a8", "#ffe66d"];

      for (let i = 0; i < CONFETTI_COUNT; i++) {
        confetti.push({
          x: Math.random() * w,
          y: Math.random() * -h * 0.3,
          vx: (Math.random() - 0.5) * 1.6,
          vy: Math.random() * 2 + 1,
          size: 4 + Math.random() * 4,
          color: colors[Math.floor(Math.random() * colors.length)],
          life: 0,
          maxLife: 260 + Math.random() * 80,
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.3
        });
      }
    }

    function updateConfetti() {
      for (let i = confetti.length - 1; i >= 0; i--) {
        const c = confetti[i];
        c.life++;
        c.vy += CONFETTI_GRAVITY;
        c.x += c.vx;
        c.y += c.vy;
        c.rotation += c.rotationSpeed;

        if (c.life > c.maxLife || c.y > canvas.height + 50) {
          confetti.splice(i, 1);
        }
      }
    }

    function checkForWinner() {
      if (!running) return;
      if (pieces.length === 0) return;

      const firstType = pieces[0].type;
      for (let i = 1; i < pieces.length; i++) {
        if (pieces[i].type !== firstType) {
          return;
        }
      }

      // We have a winner
      running = false;
      runBtn.classList.remove("running");
      celebrating = true;
      winnerType = firstType;
      spawnConfetti();
    }

    function update() {
      if (!running) {
        // Game not running but we still want explosions to fade
        for (let i = explosions.length - 1; i >= 0; i--) {
          const e = explosions[i];
          e.life++;
          if (e.life > e.maxLife) {
            explosions.splice(i, 1);
          }
        }
        return;
      }

      const speedScale = computeSpeedScales();

      // 1. Chasing, fleeing, alignment, wandering, and mouse forces
      for (let i = 0; i < pieces.length; i++) {
        const p = pieces[i];
        if (p.dead) continue;

        let target = null;
        let bestDistSq = DETECTION_RADIUS_SQ;

        let threat = null;
        let bestThreatDistSq = THREAT_RADIUS_SQ;

        // Alignment accumulators
        let alignVx = 0;
        let alignVy = 0;
        let alignCount = 0;

        for (let j = 0; j < pieces.length; j++) {
          if (i === j) continue;
          const other = pieces[j];
          if (other.dead) continue;

          const dx = other.x - p.x;
          const dy = other.y - p.y;
          const distSq = dx * dx + dy * dy;

          // Something we can beat
          if (beats(p.type, other.type)) {
            if (distSq < bestDistSq) {
              bestDistSq = distSq;
              target = other;
            }
          }

          // Something that can beat us
          if (beats(other.type, p.type)) {
            if (distSq < bestThreatDistSq) {
              bestThreatDistSq = distSq;
              threat = other;
            }
          }

          // Same type alignment
          if (other.type === p.type && distSq < ALIGN_RADIUS_SQ) {
            alignVx += other.vx;
            alignVy += other.vy;
            alignCount++;
          }
        }

        const typeScale = speedScale[p.type] || 1;

        if (target) {
          const dx = target.x - p.x;
          const dy = target.y - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const ux = dx / dist;
          const uy = dy / dist;

          const chaseSpeed = SPEED * typeScale;
          p.vx += ux * chaseSpeed;
          p.vy += uy * chaseSpeed;
        } else {
          p.wanderAngle += (Math.random() - 0.5) * 0.4;
          const wanderSpeed = WANDER_SPEED * typeScale;
          p.vx += Math.cos(p.wanderAngle) * wanderSpeed;
          p.vy += Math.sin(p.wanderAngle) * wanderSpeed;
        }

        // Flee from threat
        if (threat) {
          const dx = p.x - threat.x;
          const dy = p.y - threat.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const ux = dx / dist;
          const uy = dy / dist;

          const fleeSpeed = THREAT_FORCE * typeScale;
          p.vx += ux * fleeSpeed;
          p.vy += uy * fleeSpeed;
        }

        // Alignment with same type
        if (alignCount > 0 && ALIGN_FORCE > 0) {
          const avgVx = alignVx / alignCount;
          const avgVy = alignVy / alignCount;
          p.vx += (avgVx - p.vx) * ALIGN_FORCE;
          p.vy += (avgVy - p.vy) * ALIGN_FORCE;
        }

        // Mouse forces
        if (mouse.inside && mouseMode !== "none") {
          const dxm = mouse.x - p.x;
          const dym = mouse.y - p.y;
          const distM = Math.sqrt(dxm * dxm + dym * dym) || 1;

          if (distM <= MOUSE_RADIUS) {
            const uxM = dxm / distM;
            const uyM = dym / distM;

            if (mouseMode === "attract") {
              p.vx += uxM * MOUSE_FORCE;
              p.vy += uyM * MOUSE_FORCE;
            } else if (mouseMode === "repel") {
              p.vx -= uxM * MOUSE_FORCE;
              p.vy -= uyM * MOUSE_FORCE;
            }
          }
        }
      }

      // 2. Mild repulsion between same type pieces
      for (let i = 0; i < pieces.length; i++) {
        const a = pieces[i];
        if (a.dead) continue;
        for (let j = i + 1; j < pieces.length; j++) {
          const b = pieces[j];
          if (b.dead) continue;
          if (a.type !== b.type) continue;

          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;

          if (dist < SAME_TYPE_RADIUS) {
            const ux = dx / dist;
            const uy = dy / dist;
            const force = (SAME_TYPE_RADIUS - dist) / SAME_TYPE_RADIUS * SAME_TYPE_REPEL;

            a.vx -= ux * force;
            a.vy -= uy * force;
            b.vx += ux * force;
            b.vy += uy * force;
          }
        }
      }

      // 3. Apply friction, move, and handle boundaries
      for (let i = 0; i < pieces.length; i++) {
        const p = pieces[i];
        if (p.dead) continue;

        p.vx *= FRICTION;
        p.vy *= FRICTION;

        p.x += p.vx;
        p.y += p.vy;

        if (p.x < RADIUS) {
          p.x = RADIUS;
          p.vx *= -0.6;
        } else if (p.x > canvas.width - RADIUS) {
          p.x = canvas.width - RADIUS;
          p.vx *= -0.6;
        }
        if (p.y < RADIUS) {
          p.y = RADIUS;
          p.vy *= -0.6;
        } else if (p.y > canvas.height - RADIUS) {
          p.y = canvas.height - RADIUS;
          p.vy *= -0.6;
        }
      }

      // 4. Collisions, conversions or destruction, explosions and knockback
      for (let i = 0; i < pieces.length; i++) {
        const a = pieces[i];
        if (a.dead) continue;

        for (let j = i + 1; j < pieces.length; j++) {
          const b = pieces[j];
          if (b.dead) continue;

          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = RADIUS * 2;

          if (dist > 0 && dist < minDist) {
            let loser = null;
            let converted = false;

            if (beats(a.type, b.type)) {
              if (combatMode === "convert") {
                b.type = a.type;
              } else if (combatMode === "destroy") {
                loser = b;
              }
              converted = true;
            } else if (beats(b.type, a.type)) {
              if (combatMode === "convert") {
                a.type = b.type;
              } else if (combatMode === "destroy") {
                loser = a;
              }
              converted = true;
            }

            if (converted) {
              const ex = (a.x + b.x) / 2;
              const ey = (a.y + b.y) / 2;
              explosions.push({
                x: ex,
                y: ey,
                life: 0,
                maxLife: 18
              });
              applyExplosionKnockback(ex, ey);

              if (loser) {
                loser.dead = true;
              }
            }

            const overlap = minDist - dist;
            const nx = dx / dist;
            const ny = dy / dist;
            a.x -= nx * overlap * 0.5;
            a.y -= ny * overlap * 0.5;
            b.x += nx * overlap * 0.5;
            b.y += ny * overlap * 0.5;
          }
        }
      }

      // Remove dead pieces
      for (let i = pieces.length - 1; i >= 0; i--) {
        if (pieces[i].dead) {
          pieces.splice(i, 1);
        }
      }

      // 5. Update explosions
      for (let i = explosions.length - 1; i >= 0; i--) {
        const e = explosions[i];
        e.life++;
        if (e.life > e.maxLife) {
          explosions.splice(i, 1);
        }
      }

      // 6. Check for winner and possibly stop wave
      checkForWinner();
    }

    function updateStatus() {
      if (celebrating && winnerType) {
        const name =
          winnerType.charAt(0).toUpperCase() + winnerType.slice(1);
        const modeLabel = combatMode === "convert" ? "Convert" : "Destroy";
        statusEl.textContent =
          `${name} wins this wave. Press Run for a new wave.`;
        return;
      }

      if (pieces.length === 0) {
        statusEl.textContent = "No pieces. Click to add, then press Run.";
        return;
      }

      let rockCount = 0;
      let paperCount = 0;
      let scissorsCount = 0;

      for (const p of pieces) {
        if (p.type === "rock") rockCount++;
        else if (p.type === "paper") paperCount++;
        else if (p.type === "scissors") scissorsCount++;
      }

      const maxCount = Math.max(rockCount, paperCount, scissorsCount);
      const leaders = [];
      if (rockCount === maxCount) leaders.push("Rock");
      if (paperCount === maxCount) leaders.push("Paper");
      if (scissorsCount === maxCount) leaders.push("Scissors");

      const modeLabel = combatMode === "convert" ? "Convert" : "Destroy";

      if (leaders.length === 1) {
        statusEl.textContent =
          `Leader: ${leaders[0]} (R:${rockCount} P:${paperCount} S:${scissorsCount})`;
      } else {
        statusEl.textContent =
          `Tie (R:${rockCount} P:${paperCount} S:${scissorsCount})`;
      }
    }

    function drawPieceSprite(p) {
      const img = sprites[p.type];
      if (img && img.complete && img.naturalWidth > 0) {
        const size = SPRITE_SIZE;
        const half = size / 2;
        ctx.drawImage(img, p.x - half, p.y - half, size, size);
      } else {
        ctx.beginPath();
        ctx.arc(p.x, p.y, RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = typeColor(p.type);
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#000000aa";
        ctx.stroke();
      }
    }

    function drawExplosions() {
      for (const e of explosions) {
        const t = e.life / e.maxLife;
        const alpha = 1 - t;
        const size = 48 + 24 * t;

        ctx.save();
        ctx.globalAlpha = alpha;

        if (boomSprite && boomSprite.complete && boomSprite.naturalWidth > 0) {
          ctx.drawImage(
            boomSprite,
            e.x - size / 2,
            e.y - size / 2,
            size,
            size
          );
        } else {
          ctx.beginPath();
          ctx.arc(e.x, e.y, size / 2, 0, Math.PI * 2);
          ctx.fillStyle = "orange";
          ctx.fill();
        }

        ctx.restore();
      }
    }

    function drawConfetti() {
      for (const c of confetti) {
        const t = c.life / c.maxLife;
        const alpha = 1 - t * 0.8;

        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.translate(c.x, c.y);
        ctx.rotate(c.rotation);

        ctx.fillStyle = c.color;
        ctx.fillRect(-c.size / 2, -c.size / 2, c.size, c.size * 1.6);

        ctx.restore();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (mouse.inside && mouseMode !== "none") {
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, MOUSE_RADIUS, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.25)";
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }

      if (showVision) {
        ctx.save();
        ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
        ctx.lineWidth = 1;
        for (const p of pieces) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, DETECTION_RADIUS, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      for (const p of pieces) {
        drawPieceSprite(p);
      }

      drawExplosions();
      drawConfetti();
      updateStatus();
    }

    function loop() {
      update();
      updateConfetti();
      draw();
      requestAnimationFrame(loop);
    }
    loop();

    updateMouseModeButtons();
    updateCombatModeButtons();
  </script>
</body>
</html>
