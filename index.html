<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Rock Paper Scissors Swarm</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #ui {
      padding: 8px 12px;
      background: #222;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      border-bottom: 1px solid #333;
    }
    #ui span.label {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    button {
      border: 1px solid #444;
      background: #333;
      color: #eee;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.15s, transform 0.08s, border-color 0.15s;
    }
    button:hover {
      background: #3d3d3d;
    }
    button:active {
      transform: scale(0.97);
    }
    button.tool.selected,
    #attractBtn.selected,
    #repelBtn.selected,
    #noneBtn.selected,
    #visionBtn.selected {
      border-color: #0af;
      background: #1e3950;
    }
    #runBtn.running {
      border-color: #3fa34d;
      background: #214426;
    }
    #status {
      margin-left: auto;
      font-size: 0.9rem;
      opacity: 0.9;
      white-space: nowrap;
    }
    #gameCanvas {
      flex: 1;
      display: block;
      background: radial-gradient(circle at center, #202020, #050505 60%);
      cursor: crosshair;
    }
    @media (max-width: 600px) {
      #status {
        flex-basis: 100%;
        margin-left: 0;
        margin-top: 4px;
      }
    }
  </style>
</head>
<body>
  <div id="ui">
    <span class="label">Add:</span>
    <button class="tool selected" data-type="rock">Rock</button>
    <button class="tool" data-type="paper">Paper</button>
    <button class="tool" data-type="scissors">Scissors</button>
    <button class="tool" data-type="random">Random</button>

    <button id="runBtn">Run</button>
    <button id="stopBtn">Stop</button>
    <button id="clearBtn">Clear</button>

    <span class="label">Mouse:</span>
    <button id="attractBtn">Attract</button>
    <button id="repelBtn">Repel</button>
    <button id="noneBtn" class="selected">None</button>

    <span class="label">Vision:</span>
    <button id="visionBtn">Show Range</button>

    <span id="status">No pieces. Click to add, then press Run.</span>
  </div>

  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const uiBar = document.getElementById("ui");
    const statusEl = document.getElementById("status");
    const runBtn = document.getElementById("runBtn");
    const stopBtn = document.getElementById("stopBtn");
    const clearBtn = document.getElementById("clearBtn");
    const toolButtons = document.querySelectorAll("button.tool");
    const attractBtn = document.getElementById("attractBtn");
    const repelBtn = document.getElementById("repelBtn");
    const noneBtn = document.getElementById("noneBtn");
    const visionBtn = document.getElementById("visionBtn");

    let currentType = "rock";
    let running = false;

    const RADIUS = 12;
    const SPEED = 0.4;
    const FRICTION = 0.98;

    const MOUSE_FORCE = 1.2;
    const MOUSE_RADIUS = 160;

    const SAME_TYPE_RADIUS = 70;
    const SAME_TYPE_REPEL = 0.25;

    // New: detection radius and wandering
    const DETECTION_RADIUS = 220;
    const DETECTION_RADIUS_SQ = DETECTION_RADIUS * DETECTION_RADIUS;
    const WANDER_SPEED = 0.06;
    const WANDER_TURN_RATE = 0.4;

    const pieces = [];

    const mouse = {
      x: 0,
      y: 0,
      inside: false
    };
    let mouseMode = "none";
    let showVision = false;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - uiBar.offsetHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function typeColor(type) {
      if (type === "rock") return "#bbbbbb";
      if (type === "paper") return "#ffeaa7";
      if (type === "scissors") return "#ff7675";
      return "#ffffff";
    }

    function beats(a, b) {
      return (
        (a === "rock" && b === "scissors") ||
        (a === "paper" && b === "rock") ||
        (a === "scissors" && b === "paper")
      );
    }

    toolButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        toolButtons.forEach(b => b.classList.remove("selected"));
        btn.classList.add("selected");
        currentType = btn.getAttribute("data-type");
      });
    });

    function updateMouseModeButtons() {
      attractBtn.classList.toggle("selected", mouseMode === "attract");
      repelBtn.classList.toggle("selected", mouseMode === "repel");
      noneBtn.classList.toggle("selected", mouseMode === "none");
    }

    attractBtn.addEventListener("click", () => {
      mouseMode = "attract";
      updateMouseModeButtons();
    });

    repelBtn.addEventListener("click", () => {
      mouseMode = "repel";
      updateMouseModeButtons();
    });

    noneBtn.addEventListener("click", () => {
      mouseMode = "none";
      updateMouseModeButtons();
    });

    // Toggle vision radius visuals
    visionBtn.addEventListener("click", () => {
      showVision = !showVision;
      visionBtn.classList.toggle("selected", showVision);
    });

    canvas.addEventListener("mousemove", event => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = event.clientX - rect.left;
      mouse.y = event.clientY - rect.top;
      mouse.inside = true;
    });

    canvas.addEventListener("mouseleave", () => {
      mouse.inside = false;
    });

    canvas.addEventListener("click", event => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      let type = currentType;
      if (type === "random") {
        const options = ["rock", "paper", "scissors"];
        type = options[Math.floor(Math.random() * options.length)];
      }

      pieces.push({
        x,
        y,
        vx: 0,
        vy: 0,
        type,
        // New: give each piece a random wander heading
        wanderAngle: Math.random() * Math.PI * 2
      });
    });

    function startSimulation() {
      running = true;
      runBtn.classList.add("running");
    }

    function stopSimulation() {
      running = false;
      runBtn.classList.remove("running");
    }

    runBtn.addEventListener("click", startSimulation);
    stopBtn.addEventListener("click", stopSimulation);

    clearBtn.addEventListener("click", () => {
      pieces.length = 0;
      running = false;
      runBtn.classList.remove("running");
    });

    function update() {
      if (!running) return;

      // 1. Chasing, wandering, and mouse forces
      for (let i = 0; i < pieces.length; i++) {
        const p = pieces[i];

        let target = null;
        // Limit search to detection radius
        let bestDistSq = DETECTION_RADIUS_SQ;

        for (let j = 0; j < pieces.length; j++) {
          if (i === j) continue;
          const other = pieces[j];
          if (!beats(p.type, other.type)) continue;

          const dx = other.x - p.x;
          const dy = other.y - p.y;
          const distSq = dx * dx + dy * dy;

          if (distSq < bestDistSq) {
            bestDistSq = distSq;
            target = other;
          }
        }

        if (target) {
          // Chase target in range
          const dx = target.x - p.x;
          const dy = target.y - p.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const ux = dx / dist;
          const uy = dy / dist;

          p.vx += ux * SPEED;
          p.vy += uy * SPEED;
        } else {
          // No target in range - wander
          p.wanderAngle += (Math.random() - 0.5) * WANDER_TURN_RATE;
          p.vx += Math.cos(p.wanderAngle) * WANDER_SPEED;
          p.vy += Math.sin(p.wanderAngle) * WANDER_SPEED;
        }

        // Mouse forces
        if (mouse.inside && mouseMode !== "none") {
          const dxm = mouse.x - p.x;
          const dym = mouse.y - p.y;
          const distM = Math.sqrt(dxm * dxm + dym * dym) || 1;

          if (distM <= MOUSE_RADIUS) {
            const uxM = dxm / distM;
            const uyM = dym / distM;

            if (mouseMode === "attract") {
              p.vx += uxM * MOUSE_FORCE;
              p.vy += uyM * MOUSE_FORCE;
            } else if (mouseMode === "repel") {
              p.vx -= uxM * MOUSE_FORCE;
              p.vy -= uyM * MOUSE_FORCE;
            }
          }
        }
      }

      // 2. Mild repulsion between same type pieces
      for (let i = 0; i < pieces.length; i++) {
        for (let j = i + 1; j < pieces.length; j++) {
          const a = pieces[i];
          const b = pieces[j];
          if (a.type !== b.type) continue;

          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;

          if (dist < SAME_TYPE_RADIUS) {
            const ux = dx / dist;
            const uy = dy / dist;
            const force = (SAME_TYPE_RADIUS - dist) / SAME_TYPE_RADIUS * SAME_TYPE_REPEL;

            a.vx -= ux * force;
            a.vy -= uy * force;
            b.vx += ux * force;
            b.vy += uy * force;
          }
        }
      }

      // 3. Apply friction, move, and handle boundaries
      for (let i = 0; i < pieces.length; i++) {
        const p = pieces[i];

        p.vx *= FRICTION;
        p.vy *= FRICTION;

        p.x += p.vx;
        p.y += p.vy;

        if (p.x < RADIUS) {
          p.x = RADIUS;
          p.vx *= -0.6;
        } else if (p.x > canvas.width - RADIUS) {
          p.x = canvas.width - RADIUS;
          p.vx *= -0.6;
        }
        if (p.y < RADIUS) {
          p.y = RADIUS;
          p.vy *= -0.6;
        } else if (p.y > canvas.height - RADIUS) {
          p.y = canvas.height - RADIUS;
          p.vy *= -0.6;
        }
      }

      // 4. Collisions and conversions
      for (let i = 0; i < pieces.length; i++) {
        for (let j = i + 1; j < pieces.length; j++) {
          const a = pieces[i];
          const b = pieces[j];

          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const minDist = RADIUS * 2;

          if (dist > 0 && dist < minDist) {
            if (beats(a.type, b.type)) {
              b.type = a.type;
            } else if (beats(b.type, a.type)) {
              a.type = b.type;
            }

            const overlap = minDist - dist;
            const nx = dx / dist;
            const ny = dy / dist;
            a.x -= nx * overlap * 0.5;
            a.y -= ny * overlap * 0.5;
            b.x += nx * overlap * 0.5;
            b.y += ny * overlap * 0.5;
          }
        }
      }
    }

    function updateStatus() {
      if (pieces.length === 0) {
        statusEl.textContent = "No pieces. Click to add, then press Run.";
        return;
      }

      let rockCount = 0;
      let paperCount = 0;
      let scissorsCount = 0;

      for (const p of pieces) {
        if (p.type === "rock") rockCount++;
        else if (p.type === "paper") paperCount++;
        else if (p.type === "scissors") scissorsCount++;
      }

      const maxCount = Math.max(rockCount, paperCount, scissorsCount);
      const leaders = [];
      if (rockCount === maxCount) leaders.push("Rock");
      if (paperCount === maxCount) leaders.push("Paper");
      if (scissorsCount === maxCount) leaders.push("Scissors");

      if (leaders.length === 1) {
        statusEl.textContent =
          `Leader: ${leaders[0]} (R:${rockCount} P:${paperCount} S:${scissorsCount})`;
      } else {
        statusEl.textContent =
          `Tie (R:${rockCount} P:${paperCount} S:${scissorsCount})`;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (mouse.inside && mouseMode !== "none") {
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, MOUSE_RADIUS, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.25)";
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }

      for (const p of pieces) {
        // Optional vision radius per piece
        if (showVision) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, DETECTION_RADIUS, 0, Math.PI * 2);
          ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        ctx.beginPath();
        ctx.arc(p.x, p.y, RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = typeColor(p.type);
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#000000aa";
        ctx.stroke();

        ctx.fillStyle = "#000";
        ctx.font = "10px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        let label = "?";
        if (p.type === "rock") label = "R";
        if (p.type === "paper") label = "P";
        if (p.type === "scissors") label = "S";

        ctx.fillText(label, p.x, p.y);
      }

      updateStatus();
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }
    loop();

    updateMouseModeButtons();
  </script>
</body>
</html>
